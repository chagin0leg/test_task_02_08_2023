# Описание класса `RingBuffer`

Класс `RingBuffer<SIZE, DATA_T>` представляет собой кольцевой буфер фиксированного размера. Он реализован в виде шаблона класса, где параметр `SIZE` определяет размер буфера, а параметр `DATA_T` определяет тип данных, хранящихся в буфере (по умолчанию - `unsigned char`). Обязательное условие - размер буфера `SIZE`  является степенью двойки

Класс `RingBuffer` предоставляет следующие методы:
- `Write(DATA_T value)`: метод для записи значения `value` в буфер. Возвращает `true`, если запись прошла успешно, и `false`, если буфер полон.
- `ForceWrite(DATA_T value)`: метод также используется для записи значения в буфер. В отличие от метода `Write`, если буфер полон, метод все равно выполнит запись, перезаписывая самое старое значение. Метод возвращает `true`, если буфер был пустым перед записью, и `false` в противном случае.
- `Read(DATA_T &value)`: метод для чтения значения из буфера. Значение сохраняется в переменную `value`. Возвращает `true`, если чтение прошло успешно, и `false`, если буфер пуст.
- `First()const` и `Last()const`: методы для получения первого и последнего элемента в буфере соответственно.
- `operator[] (INDEX_T i)`: оператор индексации, который позволяет получить доступ к элементам буфера по индексу `i`.
- `IsEmpty()const` и `IsFull()const`: методы для проверки, является ли буфер пустым или полным соответственно.
- `Count()const`: метод для получения количества элементов в буфере.
- `Clear()`: метод для очистки буфера.
- `Size()`: метод для получения размера буфера.

Внутри класса определены следующие члены:
- `typedef typename SelectSizeForLength<SIZE>::Result INDEX_T;`: определение псевдонима типа `INDEX_T`, который выбирается на основе размера буфера и используется для индексации элементов в буфере.
- `BOOST_STATIC_ASSERT((SIZE&(SIZE-1))==0);`: статическое утверждение, которое проверяет, что размер буфера является степенью двойки.
- `_data[SIZE]`: массив `_data` размером `SIZE`, который служит для хранения элементов буфера.
- `volatile INDEX_T _readCount;` и `volatile INDEX_T _writeCount;`: переменные `_readCount` и `_writeCount`, которые указывают на текущую позицию чтения и записи в буфере соответственно.
- `static const INDEX_T _mask = SIZE - 1;`: константа `_mask`, которая используется для вычисления индексов элементов буфера.

Класс `RingBuffer` предназначен для эффективной работы с данными в ограниченном пространстве памяти, где новые значения перезаписывают старые значения при достижении конца буфера.

## Описание макроса `IO_REG_WRAPPER`

Макрос `IO_REG_WRAPPER` предоставляет удобный способ обернуть регистр в структуру с набором методов для работы с ним. 

Для использования макроса `IO_REG_WRAPPER` необходимо передать следующие параметры:

- `REG_NAME`: имя регистра, который будет обернут в структуру.
- `CLASS_NAME`: имя класса, которое будет присвоено созданной структуре.
- `DATA_TYPE`: тип данных, хранящихся в регистре.

Структура, созданная с помощью макроса `IO_REG_WRAPPER`, содержит следующие методы:

- `DataT Get()`: метод возвращает значение регистра.
- `Set(DataT value)`: метод устанавливает значение регистра.
- `Or(DataT value)`: метод выполняет побитовую операцию "ИЛИ" между текущим значением регистра и переданным значением.
- `And(DataT value)`: метод выполняет побитовую операцию "И" между текущим значением регистра и переданным значением.
- `Xor(DataT value)`: метод выполняет побитовую операцию "Исключающее ИЛИ" между текущим значением регистра и переданным значением.
- `AndOr(DataT andMask, DataT orMask)`: метод выполняет побитовые операции "И" и "ИЛИ" между текущим значением регистра, переданными масками "И" и "ИЛИ" соответственно.
- `BitIsSet`: метод проверяет, установлен ли определенный бит в регистре. Принимает параметр `Bit`, который указывает номер бита (от 0 до 31).
- `BitIsClear`: метод проверяет, сброшен ли определенный бит в регистре. Принимает параметр `Bit`, который указывает номер бита (от 0 до 31).

## Описание структуры `SelectSize`

Структура `SelectSize` позволяет выбрать тип данных в зависимости от значения `sizeBits`. 

Структура `SelectSize` определяет следующие поля:

- `LessOrEq8`: булевое значение, указывающее, является ли `sizeBits` меньше или равным 8.
- `LessOrEq16`: булевое значение, указывающее, является ли `sizeBits` меньше или равным 16.

Структура `SelectSize` определяет следующий тип данных:

- `Result`: тип данных, выбранный на основе условий. Если `sizeBits` меньше или равно 8, то тип данных будет `uint8_t`. Если `sizeBits` меньше или равно 16, то тип данных будет `uint16_t`. В противном случае, тип данных будет `uint32_t`.

## Описание структуры `SelectSizeForLength`

Структура `SelectSizeForLength` позволяет выбрать тип данных в зависимости от значения `size`.

Структура `SelectSizeForLength` определяет следующие поля:

- `LessOrEq8`: булевое значение, указывающее, является ли `size` меньше или равным 255 (0xff).
- `LessOrEq16`: булевое значение, указывающее, является ли `size` меньше или равным 65535 (0xffff).

Структура `SelectSizeForLength` определяет следующий тип данных:

- `Result`: тип данных, выбранный на основе условий. Если `size` меньше или равно 255 (0xff), то тип данных будет `uint8_t`. Если `size` меньше или равно 65535 (0xffff), то тип данных будет `uint16_t`. В противном случае, тип данных будет `uint32_t`.

## Описание макросов `static_assert`

Файл `static_assert.h` содержит следующие макросы для статической проверки условий во время компиляции.

- `CONCAT2(First, Second)`: макрос объединяет две строки `First` и `Second` в одну строку.
- `CONCAT(First, Second)`: макрос использует макрос `CONCAT2` для объединения двух строк `First` и `Second` в одну строку.
- `BOOST_STATIC_ASSERT_BOOL_CAST(x)`: макрос приводит значение `x` к типу `bool`.
- `BOOST_STATIC_ASSERT(B)`: макрос выполняет статическую проверку условия `B` во время компиляции. Если условие не выполняется, то происходит генерация ошибки компиляции с использованием механизма шаблонов из библиотеки Boost.
- `C_STATIC_ASSERT(expr)`: макрос выполняет статическую проверку выражения `expr` во время компиляции. Если выражение не выполняется, то происходит генерация ошибки компиляции путем создания массива с отрицательным размером.

## Описание шаблонных структур `StaticIf`

Шаблонная структура `StaticIf` предоставляет механизм условной компиляции на основе значения булевого условия `condition`. Если `condition` равно `true`, то тип `TypeIfTrue` используется в качестве результата. В противном случае, тип `TypeIfFalse` используется в качестве результата.

Для использования шаблонной структуры `StaticIf`, необходимо передать три параметра при объявлении переменной или функции:

- `condition`: булевое значение, определяющее условие для выбора типа результата.
- `TypeIfTrue`: тип, который будет использован в качестве результата, если `condition` равно `true`.
- `TypeIfFalse`: тип, который будет использован в качестве результата, если `condition` равно `false`.

Пример использования:

`typename StaticIf<true, int, float>::Result result1; // result1 имеет тип int`

`typename StaticIf<false, int, float>::Result result2; // result2 имеет тип float`
