# Класс `USART`

Класс `USART` представляет собой шаблонный класс для работы с модулем USART (Универсальный Синхронно-Асинхронный Приемопередатчик) в микроконтроллерах. Он предоставляет функциональность для инициализации и использования модуля USART.

## Публичные члены класса

### Конструктор `USART`

```cpp
USART(uint32_t *system_clock)
```

Конструктор класса `USART` принимает указатель на переменную, содержащую значение системной тактовой частоты. Он инициализирует указатель на базовый адрес регистров USART в зависимости от значения `NUMBER_OF_UART`.

### Публичное поле `RX`

```cpp
RingBuffer<128> RX;
```

Публичное поле `RX` представляет собой кольцевой буфер размером 128 байт для приема данных по USART.

### Метод `TX`

```cpp
void TX(uint8_t *data, uint16_t size)
```

Метод `TX` используется для передачи данных через USART. Он принимает указатель на массив данных `data` и размер `size` передаваемых данных. Если размер не равен нулю, метод отправляет первый байт данных и затем записывает остальные данные в кольцевой буфер `tx`, если это возможно.

### Метод `Init`

```cpp
void Init(uint32_t baud_rate, uint32_t data_bits, parity_t parity, uint32_t stop_bits)
```
Метод `Init` используется для инициализации модуля USART. Он принимает параметры скорости передачи данных `baud_rate`, количества бит данных `data_bits`, типа проверки четности `parity` и количества стоп-битов `stop_bits`. Метод настраивает соответствующие регистры и включает модуль USART.

### Метод `IRQHandler`

```cpp
void IRQHandler(void)
```

Метод `IRQHandler` представляет обработчик прерывания для модуля USART. Он проверяет различные флаги состояния регистра `SR` и выполняет соответствующие действия, такие как запись принятых данных в кольцевой буфер `RX` или передача данных из кольцевого буфера `tx`.

## Приватные члены класса

### Проверка условия компиляции

```cpp
BOOST_STATIC_ASSERT(NUMBER_OF_UART == 1);
```

Приватный член `BOOST_STATIC_ASSERT` используется для проверки условия компиляции, что значение `NUMBER_OF_UART` равно 1. Это ограничение сделано только для модуля USART1.

### Приватные поля

```cpp
USART_TypeDef *base;
uint32_t *sys_clock;
RingBuffer<128> tx;
```

Приватные поля `base`, `sys_clock` и `tx` используются для хранения базового адреса регистров USART, указателя на системную тактовую частоту и кольцевого буфера для передачи данных соответственно.

## Пояснение к содержанию методов

### Содержание метода `TX`

В методе `TX` происходит передача данных через USART (универсальный синхронно-асинхронный приемопередатчик). Пошаговое объяснений того, что происходит в этом методе:

1. Проверка размера данных: 
   - Если `size` не равен нулю, то есть есть данные для передачи, выполняется следующий код.
   - Если `size` равен нулю, то метод завершается без выполнения дальнейших действий.

2. Установка указателя на конец данных:
   - Создается указатель `end`, который указывает на конец данных (`data + size`).

3. Ожидание готовности передатчика:
   - В цикле `while` проверяется флаг готовности передатчика `USART_SR_TXE` в регистре состояния `SR` базового устройства (`base->SR`).
   - Цикл продолжается, пока флаг готовности передатчика не станет установленным (`USART_SR_TXE`).

4. Запись первого байта данных:
   - Когда флаг готовности передатчика установлен, значение первого байта данных (`*data`) записывается в регистр данных `DR` базового устройства (`base->DR`).
   - Затем указатель `data` инкриминируется, чтобы указывать на следующий байт данных.

5. Передача остальных данных:
   - В цикле `while` проверяется, что указатель `data` меньше указателя `end`, то есть еще остались данные для передачи.
   - Внутри цикла вызывается метод `Write` объекта `tx` с текущим значением `*data`.
   - Если метод `Write` возвращает `true`, то есть успешно записал данные, то указатель `data` инкриминируется, чтобы указывать на следующий байт данных.

Таким образом, метод `TX` последовательно передает данные из массива `data` через USART, ожидая готовности передатчика и записывая данные в регистр данных.

### Содержание метода `Init`

В методе `Init` происходит инициализация USART (универсальный синхронно-асинхронный приемопередатчик). Пошаговое объяснений того, что происходит в этом методе:

1. Проверка номера UART:
   - Если `NUMBER_OF_UART` равен 1, то выполняется код для инициализации USART1.
   - Если `NUMBER_OF_UART` не равен 1, то код для инициализации других UART не выполняется.

2. Включение тактирования USART1:
   - Устанавливается бит `RCC_APB2ENR_USART1EN` в регистре `APB2ENR` устройства RCC (Reset and Clock Control), чтобы включить тактирование USART1.
   - Цикл `while` ожидает, пока бит `RCC_APB2ENR_USART1EN` станет установленным, чтобы убедиться, что тактирование USART1 включено.

3. Включение тактирования GPIOA:
   - Устанавливается бит `RCC_AHB1ENR_GPIOAEN` в регистре `AHB1ENR` устройства RCC, чтобы включить тактирование порта GPIOA.
   - Цикл `while` ожидает, пока бит `RCC_AHB1ENR_GPIOAEN` станет установленным, чтобы убедиться, что тактирование GPIOA включено.

4. Настройка режима работы пинов GPIOA:
   - С помощью функции `MODIFY_REG` изменяется регистр `MODER` порта GPIOA для настройки режима работы пинов 9 и 10.
   - Устанавливаются биты `GPIO_MODER_MODE10_0` и `GPIO_MODER_MODE9` для установки пинов 9 и 10 в режим альтернативной функции.
   - Устанавливается бит `GPIO_MODER_MODE9_1` для выбора альтернативной функции USART1 на пине 9.

5. Включение прерывания USART1:
   - Вызывается функция `NVIC_EnableIRQ` с аргументом `USART1_IRQn`, чтобы разрешить прерывание от USART1.

6. Проверка состояния USART:
   - Если бит `USART_CR1_UE` в регистре `CR1` базового устройства (`base->CR1`) не установлен, то выполняется следующий код.
   - Если бит `USART_CR1_UE` уже установлен, то код для настройки USART не выполняется.

7. Настройка регистров USART:
   - Очищаются биты `USART_CR2_LINEN` и `USART_CR2_CLKEN` в регистре `CR2` базового устройства, чтобы отключить режим LIN и тактирование SCLK.
   - Очищаются биты `USART_CR3_SCEN`, `USART_CR3_IREN` и `USART_CR3_HDSEL` в регистре `CR3` базового устройства, чтобы отключить режим синхронного обмена, инфракрасный режим и полудуплексный режим.
   - Устанавливается бит `USART_CR3_EIE` в регистре `CR3` базового устройства, чтобы разрешить прерывание ошибки.

8. Настройка скорости передачи данных:
   - С помощью функции `MODIFY_REG` изменяется регистр `BRR` базового устройства для настройки делителя частоты передачи данных.
   - Значение делителя вычисляется как `SysClock / baud_rate`, где `SysClock` - частота системной тактовой частоты, а `baud_rate` - желаемая скорость передачи данных.

9. Настройка количества бит данных:
   - С помощью функции `MODIFY_REG` изменяется регистр `CR1` базового устройства для настройки количества бит данных.
   - Если `data_bits` не равно 8, то устанавливается бит `USART_CR1_M` для выбора 9-битного режима передачи данных.

10. Настройка контроля четности:
    - С помощью функции `MODIFY_REG` изменяется регистр `CR1` базового устройства для настройки контроля четности.
    - Если `parity` не равно NO, то устанавливается бит `USART_CR1_PCE` для разрешения контроля четности.
    - Если `parity` не равно EVEN, то устанавливается бит `USART_CR1_PS` для выбора нечетной четности.

11. Настройка количества стоп-битов:
    - С помощью функции `MODIFY_REG` изменяется регистр `CR2` базового устройства для настройки количества стоп-битов.
    - Если `stop_bits` не равно 1, то устанавливается бит `USART_CR2_STOP_1` для выбора 2-х стоп-битов.

12. Включение USART:
    - Устанавливается бит `USART_CR1_UE` в регистре `CR1` базового устройства, чтобы включить USART.

Таким образом, метод `Init` выполняет все необходимые настройки для инициализации USART с заданными параметрами скорости передачи данных, количества бит данных, контроля четности и количества стоп-битов.

### Содержание метода `IRQHandler`

В данном методе `IRQHandler` обрабатывается прерывание от USART (универсальный синхронно-асинхронный приемопередатчик). Пошаговое объяснений того, что происходит в этом методе:

1. Сначала проверяется условие `(READ_BIT(base->SR, USART_SR_RXNE) == (USART_SR_RXNE)) && (READ_BIT(base->CR1, USART_CR1_RXNEIE) == (USART_CR1_RXNEIE))`. Это условие проверяет, что флаг RXNE (Receive Data Register Not Empty) установлен и разрешено прерывание для приема данных. Если это условие выполняется, то выполняется следующая инструкция:
   - Вызывается метод `Write` объекта `RX`, который записывает полученный байт данных в буфер приема.

2. Если первое условие не выполняется, то проверяется условие `READ_BIT(base->SR, USART_SR_ORE) == (USART_SR_ORE)`. Это условие проверяет, что флаг ORE (Overrun Error) установлен. Если это условие выполняется, то выполняется следующая инструкция:
   - Происходит чтение регистра DR (Data Register), чтобы очистить флаг ORE. Значение регистра игнорируется с помощью `(void)`.

3. Если второе условие не выполняется, то проверяется условие `READ_BIT(base->SR, USART_SR_FE) == (USART_SR_FE)`. Это условие проверяет, что флаг FE (Framing Error) установлен. Если это условие выполняется, то выполняется следующая инструкция:
   - Происходит чтение регистра DR (Data Register), чтобы очистить флаг FE. Значение регистра игнорируется с помощью `(void)`.

4. Если третье условие не выполняется, то проверяется условие `READ_BIT(base->SR, USART_SR_NE) == (USART_SR_NE)`. Это условие проверяет, что флаг NE (Noise Error) установлен. Если это условие выполняется, то выполняется следующая инструкция:
   - Происходит чтение регистра DR (Data Register), чтобы очистить флаг NE. Значение регистра игнорируется с помощью `(void)`.

5. После обработки прерывания приема данных, проверяется условие `(READ_BIT(base->SR, USART_SR_TXE) == (USART_SR_TXE)) && (READ_BIT(base->CR1, USART_CR1_TCIE) == (USART_CR1_TCIE))`. Это условие проверяет, что флаг TXE (Transmit Data Register Empty) установлен и разрешено прерывание для передачи данных. Если это условие выполняется, то выполняется следующая инструкция:
   - Создается переменная `byte_to_transmit`, которая будет использоваться для хранения байта данных для передачи.
   - Вызывается метод `Read` объекта `tx`, который считывает байт данных из буфера передачи. Если байт данных успешно считан, то выполняется следующая инструкция:
     - В цикле ожидается, пока флаг TXE не установится (пока регистр DR не станет пустым).
     - Затем, значение переменной `byte_to_transmit` записывается в регистр DR для передачи по USART.

Таким образом, данный метод обрабатывает прерывания от USART, осуществляет прием и передачу данных через USART, а также очищает соответствующие флаги ошибок.
